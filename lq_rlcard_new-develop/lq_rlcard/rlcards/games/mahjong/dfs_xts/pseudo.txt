# -*- coding: utf-8 -*-

import math

# 伪代码
def get_mianzi(hc: list):  # 34位手牌
	depth = math.floor(sum(hc) / 3)  # 最大深度
	# 经过一些操作,得到包含所有面子的列表 mianzi_list
	mz_list = [(...), (...), ...]
	m_list = []  # 用来保存一个路径下的面子组合
	m = []  # 用来保存所有路径的面子组合,即每一条路径结束后,将mlist压入m
	stack = [hc]  # 用来保存不同深度下手牌的栈

	# dfs 辅助函数
	def dfs(mlist, d):  # d为起始深度
		if len(mlist) < depth:
			continue_count = 0  # 该层被剪掉的分支计数,最大为len(mianzi_list)
			for x in mz_list:
				stack_diff = len(stack) - d - 1  # 需要将栈弹出的次数
				_ = [stack.pop() for y in range(stack_diff)]
				hc = stack[d].copy()  # 当前深度手牌

			mlist_diff = len(mlist) - d  # 如果返回了上一层,自然要弹出在下层添加的面子
			_ = [mlist.pop() for y in range(mlist_diff)]
			# (索引,顺子?刻子?)
			index, sz, kz = x[0], x[1], x[2]
			# 如果是顺子
			if sz > 0:
				# 变位
				hc[index] -= 1
				hc[index + 1] -= 1
				hc[index + 2] -= 1
				if hc[index] >= 0 and hc[index + 1] >= 0 and hc[index + 2] >= 0:
					mlist.append(x)
				else:
					# 复位
					hc[index] += 1
					hc[index + 1] += 1
					hc[index + 2] += 1
					# 分支被剪 计数+1
					continue_count += 1
					# 同一层全被剪 说明路径到头了
					if continue_count >= len(mianzi_list):
						mlist_copy = mlist.copy()
						mlist_copy.sort()
						if mlist_copy not in m:
							m.append(mlist_copy)
					# 剪枝
					continue
			# 如果是刻子
			elif kz > 0:
				# 和上面差不多, 除了变位复位:
				# hc[index] +=3
				# hc[index] -=3

			stack.append(hc)
			dfs(mlist, d + 1)
		# 路径长度达到最大深度
		else:
			mlist_copy = mlist.copy()
			mlist_copy.sort()
			if mlist_copy not in m:
				m.append(mlist_copy)

    dfs(mlist, 0)
    # 已经得到了m, 执行面子回退
    for x in m:
    mianzi_count = len(x)
    if mianzi_count > mianzi_count_max:
      mianzi_count_max = mianzi_count
    for x in m:
    if len(x) == mianzi_count_max:
      for y in range(len(x)):
        z = x[0:y] + x[y + 1 :]
        z.sort()
        if z not in m:
          m.append(z)
  return m