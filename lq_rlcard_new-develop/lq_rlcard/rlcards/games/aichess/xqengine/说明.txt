# todo: 说明文件

# todo: 1.棋盘
在棋盘上的棋子都放在数组uc_pc_Squares[256]中(长度为256具备一定好处)，数组指标代表格子的编号，匈牙利标记uc表示每个元素占用一个字节，pc表示棋子标识
棋子标识:
A. 0表示空格(没有棋子)
B. 8~14依次表示红方的帅、仕、相、马、车、炮和兵
C. 16~22依次表示黑方的将、士、象、马、车、炮和卒

好处是判断棋子的颜色非常简单——(pc & 8)!= 0表示红方的棋子，(pc & 16)!=0表示黑方的棋子

在象棋小巫师中，选中的棋子用变量sqSelected 表示，sq代表格子的编号。判断棋子uc_pc_Squares[sq]是否被选中，只需要判断sq与sqSelected是否相等即可
sqSelected== 0表示没有棋子被选中

一个走法只用一个数子表示，即mv=sqSrc + sqDst * 256，mv代表走法，mv%256就是起始格子的编号，mv/256就是目标格子的编号
走完一步棋后，通常会把该走法赋值给变量mvLast，并把mvLast%256和mvLast/256这两个格子都做上标记，这样就能清晰地看到用户或电脑刚才走的一步棋了


# todo: 2.走法生成器
走法生成器是象棋程序中的一个重要组成部分，它可以解决几乎所有象棋规则的问题，假设棋盘使用9x10的数组，按照常规的做法，找到一个马所有的走法，这将是一件非常
痛苦的事情:
```
// 判断马的下面一格有没有子
int yDst = ySrc + 2;
if (yDst <= Y_BOTTOM && uc_pc_Squares[xSrc][ySrc + 1] == 0) {
　int xDst = xSrc + 1;
　if (xDst <= X_RIGHT && !SELF_PIECE(uc_pc_Squares[xDst][yDst])) {
　　ADD_MOVE(xSrc, ySrc, xDest, yDest);
　}
　xDst = xSrc - 1;
　if (xDst >= X_LEFT && !SELF_PIECE(uc_pc_Squares[xDst][yDst])) {
　　ADD_MOVE(xSrc, ySrc, xDest, yDest);
　}
}
// 判断马的上面一格有没有子
```

棋盘为[16 x 16]的二维数组，只不过写在程序里是uc_pc_Squares[256]

[9 x 10]的象棋棋盘在[16 x 16]的数组中的位置，将在这个棋盘上演绎马是如何走棋的，首先，预置一个常量数组ccInBoard[256]，标识哪些格子在棋盘外[紫色格子，填0]
哪些格子在棋盘内(浅色格子，填1)，所以就没有必要使用x >= X_LEFT && x <= X_RIGHT && y >= Y_TOP && y <= Y_BOTTOM 之类的语句了

取而代之的是ccInBoard[sq] != 0

其次，一维数组的好就是上下左右关系非常简明，上面一各是sq - 16，下面一格是sq + 16，左边一格是sq - 1，右边一格是sq + 1，马可以跳的点只有8个，终点
相对起点的偏移值是固定的
```
const char ccKnightDelta[4][2] = {{-33, -31}, {-18, 14}, {-14, 18}, {31, 33}}
```
而对应的马腿的偏移值是:
```
const char ccKingDelta[4] = {-16, -1, 1, 16};
```

这个数组之所以命名为ccKingDelta，是因为它也是帅(将)的偏移值。这样，找到一个马的所有走法就容易很多了。首先判断某个方向上的马腿是否有子，然后判断该方
向上的两个走法是否能走:
```
for (i = 0; i < 4; i ++) {
　sqPin = sqSrc + ccKingDelta[i];
　if (IN_BOARD(sqPin) && ucpcSquares[sqPin] == 0) {
　　for (j = 0; j < 2; j ++) {
　　　sqDst = sqSrc + ccKnightDelta[i][j];
　　　if (IN_BOARD(sqDst) && !SELF_PIECE(ucpcSquares[sqDst])) {
　　　　ADD_MOVE(sqSrc, sqDst);
　　　}
　　}
　}
}
```
用类似的办法就可以产生其他棋子的所有走法

# todo: 3.判断走法是否符合规则
让走法器尽可能的小巧，但它仍是象棋程序中最耗费时间的运算模块，有时候走法生成器真是大材小用，比如，用户点击鼠标走一步棋时，判断这步棋是否符合走法规则，存
在几种不同的考虑:
```
1.让走法生成器产生全部的走法，看看这些走法中有没有用户刚才走出的那步棋，如果没有就说明用户在乱走
2.前一种做法中，大部分工作都是白费，因为用户只是走了一个棋子，走法生成器没必要生成其他棋子的走法
3.用户只走了一步棋，而走法生成器会生成一个棋子的所有走法，这显得很浪费
```

判断一个走法是否合理，有更简单的方法，依然以马为例，假设用户的鼠标动作肯定在棋盘内的，那么判断过程如下:
```
1.马是否走了马步，即唯一是否符合ccKingDelta中的值
2.根据马步，找到对应的马腿位置，判断马腿的格子上是否有棋子
```

用K_NIGHT_PIN(sqSrc, sqDst)的函数来获取马腿的位置，如果函数返回sqSrc，则说明不是马步，这样，判断马的某个走法是否符合规则，只需要简单的判断:
```
sqPin = KNIGHT_PIN(sqSrc, sqDst)
return sqPin != sqSrc && uc_pc_Squares[sqPin] == 0
```

# todo: 4.判断将军
判断胜负，中国象棋的胜负标准就是将/帅有没有被将死或困毙，做法:
```
1.生成所有走法，如果走任意一步都会被将军，那么该局面就是被将死或困毙的局面，棋局到此结束

如何判断是否被将军呢？
2.让对方生成全部走法，看看其中有没有走法可以吃掉自己的将/帅
3.按照判断走法是否符合规则的思路，采用更简单的做法
```

第一种做法没有什么不对，但电脑象棋每秒钟需要分析上万个局面，每个局面都去生成全部走法显得太耗费时间，所以尝试第二种做法，其实就是判断将/帅是否被将军的
过程，并不复杂:
```
1.假设将/帅是车，判断它是否能吃到对方的车和将/帅，中国象棋中将/帅不能对脸规则
2.假设将/帅是炮，判断它是否能够吃到对方的炮
3.假设将/帅是马，判断它是否能够吃到对方的马，需要注意的是，将/帅的马腿用的数组是ccAdvisorDelta，而不是ccKingDelta
4.假设将/帅是过河的兵/卒，判断它是否能吃到对方的兵/卒
```

这样，一个复杂的走法生成过程方案A就被简化为简单的几个走法判断过程方案B


# todo: 5.局面评价函数
根据国际象棋程序经验，局面评价函数中最关键的因素是子力价值[后9车5象马3兵1]，这样的经验同样也适合中国象棋，并且适当的调整可以得到更好的效果，子力价值
是跟它的绝对位置相关的，最明显的例子是中国象棋中的兵/卒，过河前给它很低的分数，过河后分数大涨，越接近九宫分数越高，九宫中心甚至接近一个马或炮的分值，如
此一来，每个兵中就都会有一个与绝对位置相关的价值数组，因此程序有一个常量数组cu_cvPiecePos[7][256]，它是开源的象棋程序ElephantEye中照搬过来的

开始进行局面评价，是否应该这样做:
```
vlEvaluate = 0; // 相对于红方来说的局面评价值
for (sq = 0; sq < 256; sq ++) {
　pc = uc_pc_Squares[sq];  # 红
　if (IS_RED(pc)) { # 红
　　vlEvaluate += cu_cvPiecePos[PIECE_TYPE(pc)][sq]; # 红
　} else if (IS_BLACK(pc)) { # 红
　　vlEvaluate -= cu_cvPiecePos[PIECE_TYPE(pc)][SQUARE_FLIP(sq)]; # 红
　}
}
```

这样做太浪费时间，因为根本就没必要每次都把棋盘扫描一遍，在程序中，每走一步棋都会调用两到三次AddPiece(方一枚棋子)和DelPiece(取走一枚棋子)，可借机
更新vlEvaluate，将上面红色的部分放到AddPiece和DelPiece中

# todo: 6.Alpha-Beta搜索

写出一个Alpha-Beta搜索函数:
```
int AlphaBeta(int vlAlpha, int vlBeta, int nDepth) {
　if (nDepth == 0) {
　　return 局面评价函数;
　}
　生成全部走法;
　排序全部走法;
　for (每个生成的走法) {
　　走这个走法;
　　int vl = -AlphaBeta(-vlBeta, -vlAlpha, nDepth - 1);
　　撤消这个走法;　
　　if (vl >= vlBeta) {
　　　return vlBeta;
　　}
　　if (vl > vlAlpha) {
　　　vlAlpha = vl;
　　}
　}
　return vlAlpha;
```
但是，这样的程序根本走不出棋来，因为它返回是是一个分数，而不是一个走法，另外，还发现几个问题:
```
1.排序的依据是什么？
2.是不是每个生成的走法都可以走？
3.如果什么走法都走不出来，那么返回vlAlpha合理？
```

针对上述问题，对程序做如下改进:
```
0.如果函数在根结点出被调用，就把最佳走法作为电脑要走的棋
1.国际象棋程序的经验证明，历史标是很好的走法排序依据
2.由于走法生成器并没有考虑自杀(被将军)的情况，因此，走完一步后要检查是否被将军了，被将军时应立即退回来
3.如果没有走出任何走法，说明当前局面是杀棋或困毙局面，应该返回杀棋的分数
```

改进程序，改进的地方使用红进行标注:
```
int AlphaBeta(int vlAlpha, int vlBeta, int nDepth) {
　if (nDepth == 0) {
　　return 局面评价函数;
　}
　生成全部走法;
　按历史表排序全部走法;  # 红
　for (每个生成的走法) {
　　走这个走法;
　　if (被将军) {  # # 红
　　　撤消这个走法;  # # 红
　　} else {
　　　int vl = -AlphaBeta(-vlBeta, -vlAlpha, nDepth - 1);
　　　撤消这个走法;　
　　　if (vl >= vlBeta) {
　　　　将这个走法记录到历史表中;  # 红
　　　　return vlBeta;
　　　}
　　　if (vl > vlAlpha) {
　　　　设置最佳走法;  # 红
　　　　vlAlpha = vl;
　　　}
　　}
　}
　if (没有走过任何走法) { # 红
　　return 杀棋的分数; # 红
　}
　将最佳走法记录到历史表中; # 红
　if (根节点) { # 红
　　最佳走法就是电脑要走的棋; # 红
　}
　return vlAlpha;
}
```

# todo: 7.杀棋的分数
遇到将死或困毙的局面时，应该返回nDistance - INFINITY，这样程序就能找到最短的搜索路线，nDistance是当前结点距离根节点的步数，每走一个走法，nDistance
则+1，每撤销一个走法，nDistance则-1

当程序中使用了置换表，则此问题将变得更加复杂

# todo: 8.历史表
国际象棋的经验证明，历史表是很好的走法排序依据，那么，如何将走法记录到历史表中呢，下面介绍两类走法:
```
1.产生Beta截断走法
2.不能产生Beta截断，但它是所有PV走法(vl > vlAlpha)中最好的走法
```

历史表用一个大小为65536的数组存储，正好能将走法的数值(mv)作为指标，因此根据走法的历史表的值非常容易，即nHistoryTable[mv]

那么，一个走法记录到历史表中，究竟给nHistoryTable中的这个元素加多少分值？沿用国际的经验 -> 深度的平方，所有更新历史表的代码非常简单:
```
nHistoryTable[mv] += nDepth * nDepth;
```

# todo: 9.迭代加深和时间控制
迭代加深具有一石多鸟的功效，目前最明显的供效是充分发挥历史表的作用，浅一层搜索结束后，历史表中积累了大量非常宝贵的数据，这将大幅度减少深一层搜索的时间
在迭代加深的基础上时间时间控制，这将非常简单:
```
for (i = 1; i < MAX_DEPTH; i ++) {
　AlphaBeta(-INFINITY, INFINITY, i);
　if (超过最短搜索时间) {
　　break;
　}
}
```

也可加入其他结束迭代加深的条件，例如，当程序算出了杀棋(分支接近INFINITY或-INFINITY)时，则结束进行更深的迭代搜索

# todo: 10.克服水平线效应
克服水平线效应的方法有以下几种:
```
1.静态搜索(Quiescence): 进入静态搜索时，要考虑两种情况，一是不被将军的情况，首先尝试不走是否能够被截断，然后搜索所有吃子的走法(可按照MVV或LVA排序)
二是被将军的情况，这时就必须生成所有走法了，可按照历史表排序

2.空步裁剪(NullMove): 空步裁剪的代码非常简单，但某些条件下并不使用，一是被将军的情况下，二是进入残局时，自己一方的子力总价值小于某个阈值，三是不要
连续做两次空步裁剪，否则会导致搜索的退化

3.将军延申
```

# todo: 11.检查重复局面
重复局面的判断不是必须的，因为任何变化都只搜索固定深度，但静态搜索和将军延申会带来一个问题，遇到"解将还将"的局面，搜索就会无止境地进行下去，直到程序崩溃

两个办法解决这个问题:
```
1.限制实际搜索深度，通过nDistance来限制
2.自动识别重复局面，遇到这样的局面就根据返回和棋或杀棋的分数
```
前者实现比较简单，程序中也实现了该逻辑，检查重复局面的办法很简单，每走一个走法就把当前局面的校验码基类下来，再看看前几个局面的校验码是否与当前值相等，
当重复局面发生时，则根据双方的将军情况来判定胜负，单方面长将者判负(返回杀棋分数而不必要继续搜索了)，双长将或双方都存在非法走法则判和(返回和棋分数)

用一个rep_status函数来检查重复，如果局面存在重复，那么它的返回值将有意思:
```
return 1 + (bPerpCheck ? 2 : 0) + (bOppPerpCheck ? 4 : 0);
```

起初bPcrpCheck(本方长将)和bOppPcrpCheck(对方长将)都设为True，当一方存在非将走法时，就改为False，这样rep_status的返回值有以下几种情况:
```
1.返回0，表示无重复局面
2.返回1，表示存在重复局面，但双方都无长将(判和)
3.返回3(=1+2)，表示存在重复局面，本方单方面长将(判本方负)
4.返回5(=1+4)，表示存在重复局面，对方单方面长将(判对方负)
5.返回7(=1+2+4)，表示存在重复局面，双方长将(判和)
```

# todo: 12.zobrist校验码
将zobrist值作为局面的校验码，好处在于计算迅速，除了检查重复局面外，校验码还能产生如下作用:
```
1.作为置换表(Hash表)的键值
2.作为开局库的查找依据
```
生成的zobrist校验码与开源象棋程序ElephantEye是一致的(以空密匙的RC4密码流作为随机序列)，这样就可以使用ElephantEye的开局库了，zobrist值总共96位
放在dwKey、dwLock0和dwLock1中，其中dwKet再检查重复局面时用，也作为置换表的键值，dwLock0和dwLock1用作置换表的校验值

另外，dwLock1还是查找开局库的依据


# todo: 13.置换表
无置换表，则称不上完整的计算机博弈程序，置换表非常简单，以木棉的zobristKey % HASH_SIZE作为索引，每个置换表项存储的内容无非就是:
```
A.深度
B.标致
C.分值
D.最佳走法
E.zobristLock校验码
```
置换表的除了函数也很传统，一个ProbeHash和一个RecordHash就足够

RecordHash，采用深度优先的替换策略，RecordHash也非常简单，在判断深度后，将Hash表项中的每个值填上即可

ProbeHash如何利用置换表信息:
```
1.检查局面所对应的置换表项，如果zobristLock校验匹配，那么就认为命中(Hit)
2.是否能直接利用置换表中的结果，取决于两个因素: A.深度是否达到要求，B.非PV节点还需要考虑边界
```
第二种情况是最好的，完全利用，ProbeHash返回一个非-MATE_VALUE的值，这样就能不对该节点进行展开，如果仅仅符合第一种情况，那么该置换表项的信息仍旧是
有意义的，它的最佳走法给了一定的启发(部分利用)

# todo: 14.杀棋分数调整
从学会走棋，就已经考虑了杀棋分数，不过增加了置换表以后，这个分数要进行调整，置换表中的分值不能是距离根节点的杀棋分值，而是距离当前置换表项节点的价值，
所以当分值接近INFINITY或-INFINITY时，ProbeHash和RecordHash都要做细微的调整:
```
1.对于RecordHash: 置换表项记录的杀棋步数=实际杀棋步数 - 置换表项距离根节点的步数
2.对于ProbeHash: 实际杀棋步数 = 置换表项记录的杀棋步数 + 置换表项距离根节点的步数
```

# todo: 15.杀手走法(killer)
杀手走法就是兄弟节点中产生了Beta截断的走法，根据国际象棋的经验，杀手走法产生截断的可能性极大，所以在中国象棋中戏曲了这个经验，很显然，兄弟节点中的走法
未必在当前节点下能走，所以在尝试杀手走法以前，先要对它进行走法合理性的判断(legal_move)，这里将它大显身手，当杀手走法确实产生了截断，那么后面耗时的
generate_moves将不再继续执行

如何保存和获取兄弟节点中产生截断的走法？
可以把这个问题简化，距离根节点步数(nDistance)同样多的节点，彼此都称为兄弟节点，换句话说，亲兄弟、堂兄弟以及关系更疏远的兄弟都称为兄弟，可以把距离根
节点的步数(nDistance)作为索引值，构造一个杀手走法表，每个杀手走法表项存有两个杀手走法，走法一比走法2优先，存一个走法时，走法二就被走法一替换，走法
一被新走法替换，取走法时，先取走法一，再取走法二


# todo: 16.优化走法顺序
利用各种渠道，如置换表，杀手走法，历史表等来优化走法顺序的手段，称为"启发"，采用多种启发方式:
```
1.如果置换表中有过该局面的数据，但无法完全利用，那么多数情况下它是浅一层搜索产生截断的走法，可以首先尝试它
2.然后两个杀手走法，如果其中某个杀手走法与置换表走法一样，那么可跳过
3.然后生成全部走法，按历史表排序，再依次搜索，可排除置换表走法和两个杀手走法，这样可构造一个状态机，来描述走法顺序的若干阶段:
置换表走法 -> 杀手走法一 -> 杀手走法二 -> 生成所有走法 -> 生成的走法[循环] -> 结果

把状态机写在一个叫Next的函数中，那么Alpha-Beta的循环体就是:
…… // 初始化状态机
while ((mv = Next()) != 0) {
　MakeMove(mv);
　…… // Alpha-Beta递归调用
　UndoMakeMove(mv);
　…… // Alpha-Beta边界判断
}

在Next函数中，用了不带break的switch ... case结构:
switch (nPhase) {
case PHASE_HASH:
　nPhase = PHASE_KILLER_1;
　…… // 如果有置换表走法，就可以返回，再次调用就直接跳到 PHASE_KILLER_1
　// 注意：这里没有break！
 case PHASE_KILLER_1:
　nPhase = PHASE_KILLER_2;
　……
}
```
这就是“基于置换表的启发式Alpha-Beta搜索”，目前顶尖的电脑(国际)象棋程序都逃脱不了这种架构，只不过它们在置换表和启发算法上更加优化而已

# todo: 17.开局库
开局库几乎是每个象棋程序必备的部件，它的好处:
```
1.即使再笨的程序，开局库能使得它们在开局阶段看上去步那么业余
2.通过随机选择走法，让开局灵活多变，增加对弈的趣味性
3.使用开源象棋程序ElephantEye的开局库，开局库文件[BOOK.DAT]的结构为:
struct BookItem {
　DWORD dwLock;
　WORD wmv, wvl;
} BookTable[BOOK_SIZE];
```
其中dwLock记录了局面Zobrist校验码中的dwLock1，wmv是走法，wvl是权重(随机选择走法概率)，仅当两个相同的dwLock有不同的wmv时，wvl才有意义，搜索一
个局面时，首先不做AlphaBeta搜索，而是查找BookTable中有没有对应的项，有的话就返回一个走法，由于ElephantEye在制作开局库时按照dwLock排序，因此可
用二分查找，找到一项后，把它前后dwLock相同的所有项都取出，从中随机选择一个wmv，ElephantEye 为了压缩开局库的容量，所有对称的局面只用一项，所以当一
个局面在 BookTable中找不到时，还应该试一下它的对称局面是否在BookTable中

# todo: 18.根节点的特殊处理
程序一开局不会总是跳正马，根据ElephantEye提供的开局库，它大部分时候走中炮，有时也会走仙人指路(进兵或飞象)，可当它脱离开局库时，仍然摆脱不了思维的单
一性，例如第一步走边兵，开局库中没有这个局面，让仍旧只会跳同一边的马

解决办法: 在根节点处，让一个不是最好的走法也能在一定概率取代前一个走法
```
if (vl > vlBest) {
　vlBest = vl;
　对vlBest作小范围的随机浮动;
}
```

把根节点的搜索函数单独分离，好处:
```
1.处理思考的随机性
2.没有必要尝试Beta截断(根节点处Beta始终是+INFINITY)
3.省略了检查重复局面，获取置换表，空步裁剪等步骤
```

# todo: 19.PVS
很多计算机博弈的资料都介绍了PVS算法，但它只有当走法顺序充分优化时才能带来明显的好处，因此象棋小巫师直到最后一个版本才用了这种算法

# todo: 20.长将判负策略
由于单方面的长将不变作负的规则，0.6以前版本如果发生这种情况，想当然地基于MATE_VALUE的值，再根据杀棋步数做调整，但由于长将判负并不是针对某个单独的评分
而是跟路线有关，所以使用置换表时就会产生非常严重的后果，某个局面的信息可能来自另一条不同的路线

解决办法:
获取置换表时，利用长将判负策略搜索到的局面过滤掉，为此版本中，将长将判负的局面定为BAN_VALUE(MATE_VALUE - 100)，如果某个局面分值再WIN_VALUE(
MATE_VALUE - 200)和BAN_VALUE之间，那么这个局面就是利用长将判负策略搜索到的局面

仍旧把部分利用长将判负策略搜索到的局面记录到置换表中，因为这些局面提供了最佳走法的启发价值，反过来说，如果利用长将判负策略搜索到的局面没有最佳走法，那么
这种局面就没有必要记录到置换表

经过这种处理，程序在杀棋截断不再会走出莫名的走法



todo: pvs
    PVS(Parallel Vision Search)算法是一种用于计算机视觉领域中目标检测和跟踪的算法。它是一种用于高效搜索目标空间的方法
    PVS(Parallel Virtual Machine Sorting)算法是一种并行排序算法，适用于大规模数据集的并行排序操作。
    该算法基于分而治之的思想，将数据集分割为多个子集，在多个处理单元上并行地进行排序操作，最后将排序后的子集合并为整体有序的数据集
    PVS算法的应用范围包括但不限于以下几个方面:
    1.大规模数据排序: PVS算法可以有效地处理大规模数据集的排序操作，特别适用于分布式计算环境下的并行排序
    2.并行计算: PVS算法可以作为一种通用的并行计算模式，用于其他需要将数据集分割为多个子集进行并行操作的情况
    3.数据库查询优化: 在数据库系统中，排序是许多查询操作的重要组成部分。PVS算法可以用于优化查询操作中的排序过程，提高查询性能
    4.大数据处理：在大数据处理领域，排序是常见的操作之一。PVS算法可以应用于大规模数据集的排序，加速大数据处理过程
    5.分布式系统: PVS算法适用于分布式系统中的排序任务，可以利用多台计算机的计算能力进行并行排序，提高排序效率。
    PVS算法可以在需要进行大规模数据排序和并行计算的场景中发挥作用，特别适用于分布式环境下的并行排序任务, 它可以提高排序的效率和性能，并应用于多个领域和应用场景


todo: RC4
    RC4加密算法是Ron Rivest在1987年设计出的密钥长度可变的加密算法簇。
    起初该算法是商业机密，直到1994年，它才公诸于众。
    RC4属于对称密码算法中的序列密码(stream cipher,流密码)，它是可变密钥长度，面向字节操作的序列密码。
    它是一种基于非线性数据表变换的序列密码，它以一个足够大的数据表为基础，对表进行非线性变换，产生非线性的序列密钥。
    RC4算法取n=8，使用2^n=2^8=256个字节构成的S表和两个字节指针（i，j）,总共需要258字节的存储空间。
    补：序列密码（流密码）：
    流密码也属于对称密码，但与分组(块)加密算法不同的是，流密码不对明文数据进行分组，而是用密钥生成与明文一样长短的密码流对明文进行加密，加解密使用相同的密钥。
    也就是说，RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。
    RC4算法变量
    介绍RC4算法的几个关键变量：
     1）密钥流：RC4算法的关键是根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。
     当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节；
     2）状态向量S：长度为256，S[0],S[1].....S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换；
     3）临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T
     4）密钥K：长度为1-256字节，注意密钥的长度key_len与明文长度、密钥流的长度没有必然关系，通常密钥的长度16字节（128比特）


todo: 子力平衡
    子力平衡(Material Balance)指双方各有哪些棋子，根据国际象棋文献，后的价值为900分，车500分，象325分，兵100分，king无价，计算子力平衡是非常
    简单的，每方棋子的子力价值：MB = SUM(Np x Vp)，这里Np指棋盘上这种类型棋子的数量，Vp是此类棋子的价值，当在棋盘上子力价值比对手多，那么形势较好
    注意：老外喜欢将"吃"说成捕获(Capture)，意思就是棋子并非消失，而是暂时退场，所以说子力价值时，一定得强调在棋盘上


import time, random, struct
import pygame
from pygame.locals import *


class 物理:
	游戏是否结束 = True
	播放音效 = 0  # 1赢2输3平4将军5移动6吃


##棋子编号
棋子将 = 0
棋子士 = 1
棋子象 = 2
棋子马 = 3
棋子车 = 4
棋子炮 = 5
棋子兵 = 6

##其他常数
最大的生成走法数 = 128
最大的历史走法数 = 256
最大的搜索深度 = 64
最高分值即将死的分值 = 10000
长将判负的分值低于该值将不写入置换表 = 最高分值即将死的分值 - 100
搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 = 最高分值即将死的分值 - 200
和棋时返回的分数取负值 = 20
先行权分值 = 3
随机性分值 = 7
空步裁剪的子力边界 = 400
空步裁剪的裁剪深度 = 2
最大置换表大小 = 1 << 20
ALPHA节点的置换表项 = 1
BETA节点的置换表项 = 2
PV节点的置换表项 = 3

判断棋子是否在棋盘中的数组 = (
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
)
判断棋子是否在九宫的数组 = (
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
)
# 判断步长是否符合特定走法的数组，1=帅(将)，2=仕(士)，3=相(象)
判断步长是否符合特定走法的数组 = (
	0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0
)

根据步长判断马是否蹩腿的数组 = (
	0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, -16, 0, -16, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 16, 0, 16, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0
)

将的步长 = (-16, -1, 1, 16)

士的步长 = (-17, -15, 15, 17)

马的步长以将的步长作为马腿 = ((-33, -31), (-18, 14), (-14, 18), (31, 33))

马被将军的步长以士的步长作为马腿 = ((-33, -18), (-31, -14), (14, 31), (18, 33))

棋盘初始设置 = (
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 20, 19, 18, 17, 16, 17, 18, 19, 20, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0,
	0, 0, 0, 22, 0, 22, 0, 22, 0, 22, 0, 22, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 14, 0, 14, 0, 14, 0, 14, 0, 14, 0, 0, 0, 0,
	0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 12, 11, 10, 9, 8, 9, 10, 11, 12, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
)

子力位置价值表 = (
	(  # 帅(将)
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 11, 15, 11, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	), (  # 仕(士)
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 20, 0, 20, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 20, 0, 20, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	), (  # 相(象)
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 18, 0, 0, 0, 23, 0, 0, 0, 18, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	), (  # 马
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 90, 90, 90, 96, 90, 96, 90, 90, 90, 0, 0, 0, 0,
		0, 0, 0, 90, 96, 103, 97, 94, 97, 103, 96, 90, 0, 0, 0, 0,
		0, 0, 0, 92, 98, 99, 103, 99, 103, 99, 98, 92, 0, 0, 0, 0,
		0, 0, 0, 93, 108, 100, 107, 100, 107, 100, 108, 93, 0, 0, 0, 0,
		0, 0, 0, 90, 100, 99, 103, 104, 103, 99, 100, 90, 0, 0, 0, 0,
		0, 0, 0, 90, 98, 101, 102, 103, 102, 101, 98, 90, 0, 0, 0, 0,
		0, 0, 0, 92, 94, 98, 95, 98, 95, 98, 94, 92, 0, 0, 0, 0,
		0, 0, 0, 93, 92, 94, 95, 92, 95, 94, 92, 93, 0, 0, 0, 0,
		0, 0, 0, 85, 90, 92, 93, 78, 93, 92, 90, 85, 0, 0, 0, 0,
		0, 0, 0, 88, 85, 90, 88, 90, 88, 90, 85, 88, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	), (  # 车
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 206, 208, 207, 213, 214, 213, 207, 208, 206, 0, 0, 0, 0,
		0, 0, 0, 206, 212, 209, 216, 233, 216, 209, 212, 206, 0, 0, 0, 0,
		0, 0, 0, 206, 208, 207, 214, 216, 214, 207, 208, 206, 0, 0, 0, 0,
		0, 0, 0, 206, 213, 213, 216, 216, 216, 213, 213, 206, 0, 0, 0, 0,
		0, 0, 0, 208, 211, 211, 214, 215, 214, 211, 211, 208, 0, 0, 0, 0,
		0, 0, 0, 208, 212, 212, 214, 215, 214, 212, 212, 208, 0, 0, 0, 0,
		0, 0, 0, 204, 209, 204, 212, 214, 212, 204, 209, 204, 0, 0, 0, 0,
		0, 0, 0, 198, 208, 204, 212, 212, 212, 204, 208, 198, 0, 0, 0, 0,
		0, 0, 0, 200, 208, 206, 212, 200, 212, 206, 208, 200, 0, 0, 0, 0,
		0, 0, 0, 194, 206, 204, 212, 200, 212, 204, 206, 194, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	), (  # 炮
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 100, 100, 96, 91, 90, 91, 96, 100, 100, 0, 0, 0, 0,
		0, 0, 0, 98, 98, 96, 92, 89, 92, 96, 98, 98, 0, 0, 0, 0,
		0, 0, 0, 97, 97, 96, 91, 92, 91, 96, 97, 97, 0, 0, 0, 0,
		0, 0, 0, 96, 99, 99, 98, 100, 98, 99, 99, 96, 0, 0, 0, 0,
		0, 0, 0, 96, 96, 96, 96, 100, 96, 96, 96, 96, 0, 0, 0, 0,
		0, 0, 0, 95, 96, 99, 96, 100, 96, 99, 96, 95, 0, 0, 0, 0,
		0, 0, 0, 96, 96, 96, 96, 96, 96, 96, 96, 96, 0, 0, 0, 0,
		0, 0, 0, 97, 96, 100, 99, 101, 99, 100, 96, 97, 0, 0, 0, 0,
		0, 0, 0, 96, 97, 98, 98, 98, 98, 98, 97, 96, 0, 0, 0, 0,
		0, 0, 0, 96, 96, 97, 99, 99, 99, 97, 96, 96, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	), (  # 兵(卒)
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 11, 13, 11, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 19, 24, 34, 42, 44, 42, 34, 24, 19, 0, 0, 0, 0,
		0, 0, 0, 19, 24, 32, 37, 37, 37, 32, 24, 19, 0, 0, 0, 0,
		0, 0, 0, 19, 23, 27, 29, 30, 29, 27, 23, 19, 0, 0, 0, 0,
		0, 0, 0, 14, 18, 20, 27, 29, 27, 20, 18, 14, 0, 0, 0, 0,
		0, 0, 0, 7, 0, 13, 0, 16, 0, 13, 0, 7, 0, 0, 0, 0,
		0, 0, 0, 7, 0, 7, 0, 15, 0, 7, 0, 7, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	)
)


def 判断棋子是否在棋盘中(sq):
	return 判断棋子是否在棋盘中的数组[sq] != 0


def 判断棋子是否在九宫中(sq):
	return 判断棋子是否在九宫的数组[sq] != 0


def 获得格子的纵坐标(sq):
	return sq >> 4


def 获得格子的横坐标(sq):
	return sq & 15


def 根据坐标获得格子(x, y):
	return x + (y << 4)


def 翻转格子(sq):
	return 254 - sq


def 坐标水平镜像(x):
	return 14 - x


def 坐标垂直镜像(y):
	return 15 - y


def 格子水平镜像(sq):
	return 根据坐标获得格子(坐标水平镜像(获得格子的横坐标(sq)), 获得格子的纵坐标(sq))


def 前进一个格子的位置(sq, sd):
	return sq - 16 + (sd << 5)


def 走法是否符合帅的步长(sqSrc, sqDst):
	return 判断步长是否符合特定走法的数组[sqDst - sqSrc + 256] == 1


def 走法是否符合士的步长(sqSrc, sqDst):
	return 判断步长是否符合特定走法的数组[sqDst - sqSrc + 256] == 2


def 走法是否符合象的步长(sqSrc, sqDst):
	return 判断步长是否符合特定走法的数组[sqDst - sqSrc + 256] == 3


def 象眼的位置(sqSrc, sqDst):
	return (sqSrc + sqDst) >> 1


def 马腿的位置(sqSrc, sqDst):
	return sqSrc + 根据步长判断马是否蹩腿的数组[sqDst - sqSrc + 256]


def 是否未过河(sq, sd):
	return (sq & 0x80) != (sd << 7)


def 是否已过河(sq, sd):
	return (sq & 0x80) == (sd << 7)


def 是否在河的同一边(sqSrc, sqDst):
	return ((sqSrc ^ sqDst) & 0x80) == 0


def 是否在同一行(sqSrc, sqDst):
	return ((sqSrc ^ sqDst) & 0xf0) == 0


def 是否在同一列(sqSrc, sqDst):
	return ((sqSrc ^ sqDst) & 0x0f) == 0


def 获得红黑标记(sd):
	return 8 + (sd << 3)  # (红子是8，黑子是16)


def 获得对方红黑标记(sd):
	return 16 - (sd << 3)


def 获得走法的起点(这个走法):
	return 这个走法 & 255


def 获得走法的终点(这个走法):
	return 这个走法 >> 8


def 根据起点和终点获得走法(sqSrc, sqDst):
	return sqSrc + sqDst * 256


def 走法水平镜像(这个走法):
	return 根据起点和终点获得走法(格子水平镜像(获得走法的起点(这个走法)), 格子水平镜像(获得走法的终点(这个走法)))


# RC4密码流生成器
class RC4密码流生成器:

	def __init__(self):
		self.s = list(range(256))
		self.x, self.y = 0, 0

	def 用空密钥初始化密码流生成器(self):
		self.x = self.y = j = 0
		for i in range(256):
			j = (j + self.s[i]) & 255
			self.s[i], self.s[j] = self.s[j], self.s[i]

	def 生成密码流的下一个字节(self):
		self.x = (self.x + 1) & 255
		self.y = (self.y + self.s[self.x]) & 255
		self.s[self.x], self.s[self.y] = self.s[self.y], self.s[self.x]
		return self.s[(self.s[self.x] + self.s[self.y]) & 255]

	def 生成密码流的下四个字节(self):
		uc0, uc1, uc2, uc3 = 0, 0, 0, 0
		uc0 = self.生成密码流的下一个字节()
		uc1 = self.生成密码流的下一个字节()
		uc2 = self.生成密码流的下一个字节()
		uc3 = self.生成密码流的下一个字节()
		return uc0 + (uc1 << 8) + (uc2 << 16) + (uc3 << 24)


class Zobrist结构:

	def __init__(self):
		self.重复局面校验码, self.置换表校验码, self.开局库校验码 = 0, 0, 0

	def 用零填充Zobrist(self):
		self.重复局面校验码 = self.置换表校验码 = self.开局库校验码 = 0

	def 用密码流填充Zobrist(self, 生成器):
		self.重复局面校验码 = 生成器.生成密码流的下四个字节()
		self.置换表校验码 = 生成器.生成密码流的下四个字节()
		self.开局库校验码 = 生成器.生成密码流的下四个字节()

	def 执行XOR操作(self, 校验码):
		self.重复局面校验码 ^= 校验码.重复局面校验码
		self.置换表校验码 ^= 校验码.置换表校验码
		self.开局库校验码 ^= 校验码.开局库校验码

	def Xor2(self, zobr1, zobr2):
		self.重复局面校验码 ^= zobr1.重复局面校验码 ^ zobr2.重复局面校验码
		self.置换表校验码 ^= zobr1.置换表校验码 ^ zobr2.置换表校验码
		self.开局库校验码 ^= zobr1.开局库校验码 ^ zobr2.开局库校验码


class Zobrist表:
	Zobrist结构_玩家 = Zobrist结构()
	桌面 = [[Zobrist结构() for i in range(256)] for j in range(14)]


def 初始化Zobrist表():
	RC4密码流生成器_生成器 = RC4密码流生成器()
	RC4密码流生成器_生成器.用空密钥初始化密码流生成器()
	Zobrist表.Zobrist结构_玩家.用密码流填充Zobrist(RC4密码流生成器_生成器)
	for i in range(14):
		for j in range(256):
			Zobrist表.桌面[i][j].用密码流填充Zobrist(RC4密码流生成器_生成器)


class 历史走法信息:

	def __init__(self):
		self.最佳走法 = 0
		self.上一步吃子标记, self.被将军标记 = 0, 0
		self.重复局面校验码 = 0

	def 设置本历史走法(self, 这个走法, 上一步吃子标记, 被将军标记, dwKey_):
		self.最佳走法 = 这个走法
		self.上一步吃子标记 = 上一步吃子标记
		self.被将军标记 = 被将军标记
		self.重复局面校验码 = dwKey_


class 局面结构:

	def __init__(self):
		self.轮到谁走 = 0  # 0=红方，1=黑方
		self.棋盘上的棋子摆放 = [0 for i in range(256)]
		self.红方的子力价值, self.黑方的子力价值 = 0, 0
		self.距离根节点的步数, self.历史走法数 = 0, 0
		self.历史走法信息列表 = [历史走法信息() for i in range(最大的历史走法数)]
		self.校验码 = Zobrist结构()

	def 清空棋盘(self):
		self.轮到谁走 = self.红方的子力价值 = self.黑方的子力价值 = self.距离根节点的步数 = 0
		self.棋盘上的棋子摆放 = [0 for i in range(256)]
		self.校验码.用零填充Zobrist()

	def 初始化历史走法信息(self):
		self.历史走法信息列表[0].设置本历史走法(0, 0, self.判断是否被将军(), self.校验码.重复局面校验码)
		self.历史走法数 = 1

	def 初始化棋盘(self):
		self.清空棋盘()
		for sq in range(256):
			pc = 棋盘初始设置[sq]
			if pc != 0:
				self.在棋盘上放一枚棋子(sq, pc)
		self.初始化历史走法信息()

	def 交换走子方(self):
		self.轮到谁走 = 1 - self.轮到谁走
		self.校验码.执行XOR操作(Zobrist表.Zobrist结构_玩家)

	def 在棋盘上放一枚棋子(self, sq, pc):
		self.棋盘上的棋子摆放[sq] = pc
		# 红方加分，黑方(注意"子力位置价值表"取值要颠倒)减分
		if pc < 16:
			self.红方的子力价值 += 子力位置价值表[pc - 8][sq]
			self.校验码.执行XOR操作(Zobrist表.桌面[pc - 8][sq])
		else:
			self.黑方的子力价值 += 子力位置价值表[pc - 16][翻转格子(sq)]
			self.校验码.执行XOR操作(Zobrist表.桌面[pc - 9][sq])

	def 从棋盘上拿走一枚棋子(self, sq, pc):
		self.棋盘上的棋子摆放[sq] = 0
		# 红方减分，黑方(注意"子力位置价值表"取值要颠倒)加分
		if pc < 16:
			self.红方的子力价值 -= 子力位置价值表[pc - 8][sq]
			self.校验码.执行XOR操作(Zobrist表.桌面[pc - 8][sq])
		else:
			self.黑方的子力价值 -= 子力位置价值表[pc - 16][翻转格子(sq)]
			self.校验码.执行XOR操作(Zobrist表.桌面[pc - 9][sq])

	def 局面评价函数(self):
		return (self.红方的子力价值 - self.黑方的子力价值 if self.轮到谁走 == 0 else self.黑方的子力价值 - self.红方的子力价值) + 先行权分值

	def 是否被将军(self):
		return self.历史走法信息列表[self.历史走法数 - 1].被将军标记

	def 上一步是否吃子(self):  # 上一步是否吃子
		return self.历史走法信息列表[self.历史走法数 - 1].上一步吃子标记 != 0

	def 移动一步棋的棋子(self, 这个走法):
		sqSrc = 获得走法的起点(这个走法)
		sqDst = 获得走法的终点(这个走法)
		上一步吃子标记 = self.棋盘上的棋子摆放[sqDst]
		if 上一步吃子标记 != 0:
			self.从棋盘上拿走一枚棋子(sqDst, 上一步吃子标记)
		pc = self.棋盘上的棋子摆放[sqSrc]
		self.从棋盘上拿走一枚棋子(sqSrc, pc)
		self.在棋盘上放一枚棋子(sqDst, pc)
		return 上一步吃子标记

	def 撤消移动一步棋的棋子(self, 这个走法, 上一步吃子标记):
		sqSrc = 获得走法的起点(这个走法)
		sqDst = 获得走法的终点(这个走法)
		pc = self.棋盘上的棋子摆放[sqDst]
		self.从棋盘上拿走一枚棋子(sqDst, pc)
		self.在棋盘上放一枚棋子(sqSrc, pc)
		if 上一步吃子标记 != 0:
			self.在棋盘上放一枚棋子(sqDst, 上一步吃子标记)

	def 走一步棋(self, 这个走法):  # 走一步棋
		重复局面校验码 = self.校验码.重复局面校验码
		pcCaptured = self.移动一步棋的棋子(这个走法)
		if self.判断是否被将军():
			self.撤消移动一步棋的棋子(这个走法, pcCaptured)
			return False
		self.交换走子方()
		self.历史走法信息列表[self.历史走法数].设置本历史走法(这个走法, pcCaptured, self.判断是否被将军(), 重复局面校验码)
		self.历史走法数 += 1
		self.距离根节点的步数 += 1
		return True

	def 撤消走一步棋(self):
		self.距离根节点的步数 -= 1
		self.历史走法数 -= 1
		self.交换走子方()
		self.撤消移动一步棋的棋子(self.历史走法信息列表[self.历史走法数].最佳走法, self.历史走法信息列表[self.历史走法数].上一步吃子标记)

	def 走一步空步(self):  # 走一步空步
		重复局面校验码 = self.校验码.重复局面校验码
		self.交换走子方()
		self.历史走法信息列表[self.历史走法数].设置本历史走法(0, 0, False, 重复局面校验码)
		self.历史走法数 += 1
		self.距离根节点的步数 += 1

	def 撤消走一步空步(self):  # 撤消走一步空步
		self.距离根节点的步数 -= 1
		self.历史走法数 -= 1
		self.交换走子方()

	def 生成所有走法(self, 所有的走法, 只生成吃子走法=False):  # 如果"只生成吃子走法"为"TRUE"则只生成吃子走法
		# 生成所有走法，需要经过以下几个步骤：
		总共有几个走法 = 0
		pcSelfSide = 获得红黑标记(self.轮到谁走)
		pcOppSide = 获得对方红黑标记(self.轮到谁走)
		for sqSrc in range(256):
			# 1. 找到一个本方棋子，再做以下判断：
			pcSrc = self.棋盘上的棋子摆放[sqSrc]
			if (pcSrc & pcSelfSide) == 0:
				continue
			# 2. 根据棋子确定走法
			switch = pcSrc - pcSelfSide
			if switch == 棋子将:
				for i in range(4):
					sqDst = sqSrc + 将的步长[i]
					if not 判断棋子是否在九宫中(sqDst):
						continue
					pcDst = self.棋盘上的棋子摆放[sqDst]
					if (pcDst & pcOppSide) != 0 if 只生成吃子走法 else (pcDst & pcSelfSide) == 0:
						所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
						总共有几个走法 += 1
			elif switch == 棋子士:
				for i in range(4):
					sqDst = sqSrc + 士的步长[i]
					if not 判断棋子是否在九宫中(sqDst):
						continue
					pcDst = self.棋盘上的棋子摆放[sqDst]
					if (pcDst & pcOppSide) != 0 if 只生成吃子走法 else (pcDst & pcSelfSide) == 0:
						所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
						总共有几个走法 += 1
			elif switch == 棋子象:
				for i in range(4):
					sqDst = sqSrc + 士的步长[i]
					if not (判断棋子是否在棋盘中(sqDst) and 是否未过河(sqDst, self.轮到谁走) and self.棋盘上的棋子摆放[sqDst] == 0):
						continue
					sqDst += 士的步长[i]
					pcDst = self.棋盘上的棋子摆放[sqDst]
					if (pcDst & pcOppSide) != 0 if 只生成吃子走法 else (pcDst & pcSelfSide) == 0:
						所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
						总共有几个走法 += 1
			elif switch == 棋子马:
				for i in range(4):
					sqDst = sqSrc + 将的步长[i]
					if self.棋盘上的棋子摆放[sqDst] != 0:
						continue
					for j in range(2):
						sqDst = sqSrc + 马的步长以将的步长作为马腿[i][j]
						if not 判断棋子是否在棋盘中(sqDst):
							continue
						pcDst = self.棋盘上的棋子摆放[sqDst]
						if (pcDst & pcOppSide) != 0 if 只生成吃子走法 else (pcDst & pcSelfSide) == 0:
							所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
							总共有几个走法 += 1
			elif switch == 棋子车:
				for i in range(4):
					nDelta = 将的步长[i]
					sqDst = sqSrc + nDelta
					while 判断棋子是否在棋盘中(sqDst):
						pcDst = self.棋盘上的棋子摆放[sqDst]
						if pcDst == 0:
							if not 只生成吃子走法:
								所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
								总共有几个走法 += 1
						else:
							if (pcDst & pcOppSide) != 0:
								所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
								总共有几个走法 += 1
							break
						sqDst += nDelta
			elif switch == 棋子炮:
				for i in range(4):
					nDelta = 将的步长[i]
					sqDst = sqSrc + nDelta
					while 判断棋子是否在棋盘中(sqDst):
						pcDst = self.棋盘上的棋子摆放[sqDst]
						if pcDst == 0:
							if not 只生成吃子走法:
								所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
								总共有几个走法 += 1
						else:
							break
						sqDst += nDelta
					sqDst += nDelta
					while 判断棋子是否在棋盘中(sqDst):
						pcDst = self.棋盘上的棋子摆放[sqDst]
						if pcDst != 0:
							if (pcDst & pcOppSide) != 0:
								所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
								总共有几个走法 += 1
							break
						sqDst += nDelta
			elif switch == 棋子兵:
				sqDst = 前进一个格子的位置(sqSrc, self.轮到谁走)
				if 判断棋子是否在棋盘中(sqDst):
					pcDst = self.棋盘上的棋子摆放[sqDst]
					if (pcDst & pcOppSide) != 0 if 只生成吃子走法 else (pcDst & pcSelfSide) == 0:
						所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
						总共有几个走法 += 1
				if 是否已过河(sqSrc, self.轮到谁走):
					for nDelta in range(-1, 2, 2):
						sqDst = sqSrc + nDelta
						if 判断棋子是否在棋盘中(sqDst):
							pcDst = self.棋盘上的棋子摆放[sqDst]
							if (pcDst & pcOppSide) != 0 if 只生成吃子走法 else (pcDst & pcSelfSide) == 0:
								所有的走法[总共有几个走法] = 根据起点和终点获得走法(sqSrc, sqDst)
								总共有几个走法 += 1
		return 总共有几个走法

	def 判断走法是否合法(self, 这个走法):
		# 判断走法是否合法，需要经过以下的判断过程：
		# 1. 判断起始格是否有自己的棋子
		sqSrc = 获得走法的起点(这个走法)
		pcSrc = self.棋盘上的棋子摆放[sqSrc]
		pcSelfSide = 获得红黑标记(self.轮到谁走)
		if (pcSrc & pcSelfSide) == 0:
			return False
		# 2. 判断目标格是否有自己的棋子
		sqDst = 获得走法的终点(这个走法)
		pcDst = self.棋盘上的棋子摆放[sqDst]
		if (pcDst & pcSelfSide) != 0:
			return False
		# 3. 根据棋子的类型检查走法是否合理
		switch = pcSrc - pcSelfSide
		if switch == 棋子将:
			return 判断棋子是否在九宫中(sqDst) and 走法是否符合帅的步长(sqSrc, sqDst)
		elif switch == 棋子士:
			return 判断棋子是否在九宫中(sqDst) and 走法是否符合士的步长(sqSrc, sqDst)
		elif switch == 棋子象:
			return 是否在河的同一边(sqSrc, sqDst) and 走法是否符合象的步长(sqSrc, sqDst) and self.棋盘上的棋子摆放[象眼的位置(sqSrc, sqDst)] == 0
		elif switch == 棋子马:
			sqPin = 马腿的位置(sqSrc, sqDst)
			return sqPin != sqSrc and self.棋盘上的棋子摆放[sqPin] == 0
		elif switch == 棋子车 or switch == 棋子炮:
			if 是否在同一行(sqSrc, sqDst):
				nDelta = -1 if sqDst < sqSrc else 1
			elif 是否在同一列(sqSrc, sqDst):
				nDelta = -16 if sqDst < sqSrc else 16
			else:
				return False
			sqPin = sqSrc + nDelta
			while sqPin != sqDst and self.棋盘上的棋子摆放[sqPin] == 0:
				sqPin += nDelta
			if sqPin == sqDst:
				return pcDst == 0 or pcSrc - pcSelfSide == 棋子车
			elif pcDst != 0 and pcSrc - pcSelfSide == 棋子炮:
				sqPin += nDelta
				while sqPin != sqDst and self.棋盘上的棋子摆放[sqPin] == 0:
					sqPin += nDelta
				return sqPin == sqDst
			else:
				return False
		elif switch == 棋子兵:
			if 是否已过河(sqDst, self.轮到谁走) and (sqDst == sqSrc - 1 or sqDst == sqSrc + 1):
				return True
			return sqDst == 前进一个格子的位置(sqSrc, self.轮到谁走)
		else:
			return False

	def 判断是否被将军(self):
		pcSelfSide = 获得红黑标记(self.轮到谁走)
		pcOppSide = 获得对方红黑标记(self.轮到谁走)
		# 找到棋盘上的帅(将)，再做以下判断：
		for sqSrc in range(256):
			if self.棋盘上的棋子摆放[sqSrc] != pcSelfSide + 棋子将:
				continue
			# 1. 判断是否被对方的兵(卒)将军
			if self.棋盘上的棋子摆放[前进一个格子的位置(sqSrc, self.轮到谁走)] == pcOppSide + 棋子兵:
				return True
			for nDelta in range(-1, 2, 2):
				if self.棋盘上的棋子摆放[sqSrc + nDelta] == pcOppSide + 棋子兵:
					return True
			# 2. 判断是否被对方的马将军(以仕(士)的步长当作马腿)
			for i in range(4):
				if self.棋盘上的棋子摆放[sqSrc + 士的步长[i]] != 0:
					continue
				for j in range(2):
					pcDst = self.棋盘上的棋子摆放[sqSrc + 马被将军的步长以士的步长作为马腿[i][j]]
					if pcDst == pcOppSide + 棋子马:
						return True
			# 3. 判断是否被对方的车或炮将军(包括将帅对脸)
			for i in range(4):
				nDelta = 将的步长[i]
				sqDst = sqSrc + nDelta
				while 判断棋子是否在棋盘中(sqDst):
					pcDst = self.棋盘上的棋子摆放[sqDst]
					if pcDst != 0:
						if pcDst == pcOppSide + 棋子车 or pcDst == pcOppSide + 棋子将:
							return True
						break
					sqDst += nDelta
				sqDst += nDelta
				while 判断棋子是否在棋盘中(sqDst):
					pcDst = self.棋盘上的棋子摆放[sqDst]
					if pcDst != 0:
						if pcDst == pcOppSide + 棋子炮:
							return True
						break
					sqDst += nDelta
			return False
		return False

	def 判断是否被杀(self):
		所有的走法 = [0 for i in range(最大的生成走法数)]
		nGenMoveNum = self.生成所有走法(所有的走法)
		for i in range(nGenMoveNum):
			pcCaptured = self.移动一步棋的棋子(所有的走法[i])
			if not self.判断是否被将军():
				self.撤消移动一步棋的棋子(所有的走法[i], pcCaptured)
				return False
			else:
				self.撤消移动一步棋的棋子(所有的走法[i], pcCaptured)
		return True

	def 和棋分值(self):
		return -和棋时返回的分数取负值 if (self.距离根节点的步数 & 1) == 0 else 和棋时返回的分数取负值

	def 检测重复局面(self, 重复次数=1):
		是否检查本方 = False
		本方长将 = 对方长将 = True
		lpmvs = self.历史走法数 - 1  # 历史走法数减1，作为最后那一步的索引值
		while self.历史走法信息列表[lpmvs].最佳走法 != 0 and self.历史走法信息列表[lpmvs].上一步吃子标记 == 0:
			if 是否检查本方:
				本方长将 = 本方长将 and self.历史走法信息列表[lpmvs].被将军标记
				if self.历史走法信息列表[lpmvs].重复局面校验码 == self.校验码.重复局面校验码:
					重复次数 -= 1
					if 重复次数 == 0:
						return 1 + (2 if 本方长将 else 0) + (4 if 对方长将 else 0)
			else:
				对方长将 = 对方长将 and self.历史走法信息列表[lpmvs].被将军标记
			是否检查本方 = not 是否检查本方
			lpmvs -= 1
		return 0

	def 重复局面分值(self, nRepStatus):
		vlReturn = (0 if (nRepStatus & 2) == 0 else self.距离根节点的步数 - 长将判负的分值低于该值将不写入置换表) + (
			0 if (nRepStatus & 4) == 0 else 长将判负的分值低于该值将不写入置换表 - self.距离根节点的步数)
		return self.和棋分值() if vlReturn == 0 else vlReturn

	def 判断是否允许空步裁剪(self):
		return (self.红方的子力价值 if self.轮到谁走 == 0 else self.黑方的子力价值) > 空步裁剪的子力边界

	def 对局面镜像(self, posMirror):
		posMirror.清空棋盘()
		for sq in range(256):
			pc = self.棋盘上的棋子摆放[sq]
			if pc != 0:
				posMirror.在棋盘上放一枚棋子(格子水平镜像(sq), pc)
		if self.轮到谁走 == 1:
			posMirror.交换走子方()
		posMirror.初始化历史走法信息()


当前棋局 = 局面结构()  # 局面实例

# "生成所有走法"参数
只生成吃子走法参数 = True


class 置换表项结构:

	def __init__(self):
		self.深度, self.标志 = 0, 0
		self.分值 = 0
		self.最佳走法, self.wReserved = 0, 0
		self.置换表校验码, self.开局库校验码 = 0, 0


class 与搜索有关的全局变量:
	电脑走的棋 = 0
	历史表 = [0 for i in range(65536)]
	杀手走法表 = [[0, 0] for i in range(最大的搜索深度)]
	置换表 = [置换表项结构() for i in range(最大置换表大小)]
	开局库 = {}


def 装入开局库():
	f = open('BOOK.DAT', 'rb')
	s = struct.calcsize('IHH')
	l = []
	a = f.read(s)
	while a:
		v = struct.unpack('IHH', a)
		l.append(v)
		a = f.read(s)
	f.close()
	for i in l:
		与搜索有关的全局变量.开局库[i[0]] = 与搜索有关的全局变量.开局库.get(i[0], [])
		与搜索有关的全局变量.开局库[i[0]].append((i[1], i[2]))


def 搜索开局库():
	所有的走法 = []
	走法的权重 = []
	局面镜像 = 局面结构()
	# 搜索开局库的过程有以下几个步骤
	# 1. 如果没有开局库，则立即返回
	if not 与搜索有关的全局变量.开局库:
		return 0
	# 2. 搜索当前局面
	bMirror = False
	lpbk = 与搜索有关的全局变量.开局库.get(当前棋局.校验码.开局库校验码, None)
	if lpbk == None:
		# 3. 如果没有找到，那么搜索当前局面的镜像局面
		bMirror = True
		当前棋局.对局面镜像(局面镜像)
		lpbk = 与搜索有关的全局变量.开局库.get(局面镜像.校验码.开局库校验码, None)
		if lpbk == None:
			return 0  # 4. 如果镜像局面也没找到，则立即返回
	# 5. 把走法和分值写入到"所有的走法"和"走法的权重"列表中
	for 走法 in lpbk:
		这个走法 = 走法水平镜像(走法[0]) if bMirror else 走法[0]
		if 当前棋局.判断走法是否合法(这个走法):
			所有的走法.append(这个走法)
			走法的权重.append(走法[1])
	# 6. 根据权重随机选择一个走法
	return random.choices(所有的走法, 走法的权重)[0]


# 提取置换表项

def 提取置换表项(vlAlpha, vlBeta, 当前深度, 这个走法):
	hsh = 与搜索有关的全局变量.置换表[当前棋局.校验码.重复局面校验码 & (最大置换表大小 - 1)]
	if hsh.置换表校验码 != 当前棋局.校验码.置换表校验码 or hsh.开局库校验码 != 当前棋局.校验码.开局库校验码:
		这个走法[0] = 0
		return -最高分值即将死的分值
	这个走法[0] = hsh.最佳走法
	bMate = False  # 杀棋标志：如果是杀棋，那么不需要满足深度条件
	if hsh.分值 > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了:
		if hsh.分值 < 长将判负的分值低于该值将不写入置换表:
			return -最高分值即将死的分值  # 可能导致搜索的不稳定性，立刻退出，但最佳着法可能拿到
		hsh.分值 -= 当前棋局.距离根节点的步数
		bMate = True
	elif hsh.分值 < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了:
		if hsh.分值 > -长将判负的分值低于该值将不写入置换表:
			return -最高分值即将死的分值  # 同上
		hsh.分值 += 当前棋局.距离根节点的步数
		bMate = True
	if hsh.深度 >= 当前深度 or bMate:
		if hsh.标志 == BETA节点的置换表项:
			return hsh.分值 if hsh.分值 >= vlBeta else -最高分值即将死的分值
		elif hsh.标志 == ALPHA节点的置换表项:
			return hsh.分值 if hsh.分值 <= vlAlpha else -最高分值即将死的分值
		return hsh.分值
	return -最高分值即将死的分值


# 保存置换表项

def 保存置换表项(nFlag, vl, 当前深度, 这个走法):
	hsh = 与搜索有关的全局变量.置换表[当前棋局.校验码.重复局面校验码 & (最大置换表大小 - 1)]
	if hsh.深度 > 当前深度:
		return
	hsh.标志 = nFlag
	hsh.深度 = 当前深度
	if vl > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了:
		if 这个走法 == 0 and vl <= 长将判负的分值低于该值将不写入置换表:
			return  # 可能导致搜索的不稳定性，并且没有最佳着法，立刻退出
		hsh.分值 = vl + 当前棋局.距离根节点的步数
	elif vl < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了:
		if 这个走法 == 0 and vl >= -长将判负的分值低于该值将不写入置换表:
			return  # 同上
		hsh.分值 = vl - 当前棋局.距离根节点的步数
	else:
		hsh.分值 = vl
	hsh.最佳走法 = 这个走法
	hsh.置换表校验码 = 当前棋局.校验码.置换表校验码
	hsh.开局库校验码 = 当前棋局.校验码.开局库校验码
	与搜索有关的全局变量.置换表[当前棋局.校验码.重复局面校验码 & (最大置换表大小 - 1)] = hsh


MvvLva每种子力的价值 = (
	0, 0, 0, 0, 0, 0, 0, 0,
	5, 1, 1, 3, 4, 3, 2, 0,
	5, 1, 1, 3, 4, 3, 2, 0
)


def 求MvvLva值(这个走法):
	return (MvvLva每种子力的价值[当前棋局.棋盘上的棋子摆放[获得走法的终点(这个走法)]] << 3) - MvvLva每种子力的价值[当前棋局.棋盘上的棋子摆放[获得走法的起点(这个走法)]]


def 按MvvLva值排序的比较函数(lpmv1, lpmv2):
	return 求MvvLva值(lpmv2) - 求MvvLva值(lpmv1)


def 按历史表排序的比较函数(lpmv1, lpmv2):
	return 与搜索有关的全局变量.历史表[lpmv2] - 与搜索有关的全局变量.历史表[lpmv1]


def 快速排序法内部函数(arr, low, high, compar):
	i = low - 1  # 最小元素索引
	pivot = arr[high]
	for j in range(low, high):
		# 当前元素小于或等于 pivot
		if compar(arr[j], pivot) <= 0:
			i = i + 1
			arr[i], arr[j] = arr[j], arr[i]
	arr[i + 1], arr[high] = arr[high], arr[i + 1]
	return i + 1


def 快速排序法(arr, low, high, compar):
	if low < high:
		pi = 快速排序法内部函数(arr, low, high, compar)
		快速排序法(arr, low, pi - 1, compar)
		快速排序法(arr, pi + 1, high, compar)


走法排序阶段之置换表 = 0
走法排序阶段之杀手走法一 = 1
走法排序阶段之杀手走法二 = 2
走法排序阶段之生成所有走法 = 3
走法排序阶段之历史表启发 = 4


class 走法排序结构:

	def __init__(self):
		self.置换表走法, self.杀手走法一, self.杀手走法二 = 0, 0, 0
		self.当前阶段, self.当前采用第几个走法, self.总共有几个走法 = 0, 0, 0
		self.所有的走法 = [0 for i in range(最大的生成走法数)]

	def 初始化设定置换表走法和两个杀手走法(self, mvHash_):
		self.置换表走法 = mvHash_
		self.杀手走法一 = 与搜索有关的全局变量.杀手走法表[当前棋局.距离根节点的步数][0]
		self.杀手走法二 = 与搜索有关的全局变量.杀手走法表[当前棋局.距离根节点的步数][1]
		self.当前阶段 = 走法排序阶段之置换表

	def 得到下一个走法(self):
		if self.当前阶段 == 走法排序阶段之置换表:
			# "当前阶段"表示着法启发的若干阶段，依次为：
			# 0. 置换表着法启发，完成后立即进入下一阶段；
			self.当前阶段 = 走法排序阶段之杀手走法一
			if self.置换表走法 != 0:
				return self.置换表走法
		if self.当前阶段 == 走法排序阶段之杀手走法一:
			# 1. 杀手着法启发(第一个杀手着法)，完成后立即进入下一阶段；
			self.当前阶段 = 走法排序阶段之杀手走法二
			if self.杀手走法一 != self.置换表走法 and self.杀手走法一 != 0 and 当前棋局.判断走法是否合法(self.杀手走法一):
				return self.杀手走法一
		# 2. 杀手着法启发(第二个杀手着法)，完成后立即进入下一阶段；
		if self.当前阶段 == 走法排序阶段之杀手走法二:
			self.当前阶段 = 走法排序阶段之生成所有走法
			if self.杀手走法二 != self.置换表走法 and self.杀手走法二 != 0 and 当前棋局.判断走法是否合法(self.杀手走法二):
				return self.杀手走法二
		# 3. 生成所有着法，完成后立即进入下一阶段；
		if self.当前阶段 == 走法排序阶段之生成所有走法:
			self.当前阶段 = 走法排序阶段之历史表启发
			self.总共有几个走法 = 当前棋局.生成所有走法(self.所有的走法)
			快速排序法(self.所有的走法, 0, self.总共有几个走法, 按历史表排序的比较函数)
			self.当前采用第几个走法 = 0
		# 4. 对剩余着法做历史表启发；
		if self.当前阶段 == 走法排序阶段之历史表启发:
			while self.当前采用第几个走法 < self.总共有几个走法:
				这个走法 = self.所有的走法[self.当前采用第几个走法]
				self.当前采用第几个走法 += 1
				if 这个走法 != self.置换表走法 and 这个走法 != self.杀手走法一 and 这个走法 != self.杀手走法二:
					return 这个走法
		# 5. 没有着法了，返回零。
		return 0


def 对最佳走法的处理(这个走法, 当前深度):
	与搜索有关的全局变量.历史表[这个走法] += 当前深度 * 当前深度
	lpmvKillers = 与搜索有关的全局变量.杀手走法表[当前棋局.距离根节点的步数]
	if lpmvKillers[0] != 这个走法:
		lpmvKillers[1] = lpmvKillers[0]
		lpmvKillers[0] = 这个走法


def 静态搜索过程(vlAlpha, vlBeta):
	所有的走法 = [0 for i in range(最大的生成走法数)]
	# 一个静态搜索分为以下几个阶段
	# 1. 检查重复局面
	vl = 当前棋局.检测重复局面()
	if vl != 0:
		return 当前棋局.重复局面分值(vl)
	# 2. 到达极限深度就返回局面评价
	if 当前棋局.距离根节点的步数 == 最大的搜索深度:
		return 当前棋局.局面评价函数()
	# 3. 初始化最佳值
	vlBest = -最高分值即将死的分值  # 这样可以知道，是否一个走法都没走过(杀棋)
	if 当前棋局.是否被将军():
		# 4. 如果被将军，则生成全部走法
		总共有几个走法 = 当前棋局.生成所有走法(所有的走法)
		快速排序法(所有的走法, 0, 总共有几个走法, 按历史表排序的比较函数)
	else:
		# 5. 如果不被将军，先做局面评价
		vl = 当前棋局.局面评价函数()
		if vl > vlBest:
			vlBest = vl
			if vl >= vlBeta:
				return vl
			if vl > vlAlpha:
				vlAlpha = vl
		# 6. 如果局面评价没有截断，再生成吃子走法
		总共有几个走法 = 当前棋局.生成所有走法(所有的走法, 只生成吃子走法参数)
		快速排序法(所有的走法, 0, 总共有几个走法, 按MvvLva值排序的比较函数)
	# 7. 逐一走这些走法，并进行递归
	for i in range(总共有几个走法):
		if 当前棋局.走一步棋(所有的走法[i]):
			vl = -静态搜索过程(-vlBeta, -vlAlpha)
			当前棋局.撤消走一步棋()
			# 8. 进行Alpha-Beta大小判断和截断
			if vl > vlBest:  # 找到最佳值(但不能确定是Alpha、PV还是Beta走法)
				vlBest = vl  # "vlBest"就是目前要返回的最佳值，可能超出Alpha-Beta边界
				if vl >= vlBeta:  # 找到一个Beta走法
					return vl  # Beta截断
				if vl > vlAlpha:  # 找到一个PV走法
					vlAlpha = vl  # 缩小Alpha-Beta边界
	# 9. 所有走法都搜索完了，返回最佳值
	return 当前棋局.距离根节点的步数 - 最高分值即将死的分值 if vlBest == -最高分值即将死的分值 else vlBest


# "超出边界的AlphaBeta搜索过程"的参数
不进行空步裁剪 = True


def 超出边界的AlphaBeta搜索过程(vlAlpha, vlBeta, 当前深度, 是否不进行空步裁剪=False):
	置换表走法 = [0]  # =====================================
	走法排序结构_走法排序 = 走法排序结构()
	# 一个Alpha-Beta完全搜索分为以下几个阶段
	# 1. 到达水平线，则调用静态搜索(注意：由于空步裁剪，深度可能小于零)
	if 当前深度 <= 0:
		return 静态搜索过程(vlAlpha, vlBeta)
	# 1-1. 检查重复局面(注意：不要在根节点检查，否则就没有走法了)
	vl = 当前棋局.检测重复局面()
	if vl != 0:
		return 当前棋局.重复局面分值(vl)
	# 1-2. 到达极限深度就返回局面评价
	if 当前棋局.距离根节点的步数 == 最大的搜索深度:
		return 当前棋局.局面评价函数()
	# 1-3. 尝试置换表裁剪，并得到置换表走法
	vl = 提取置换表项(vlAlpha, vlBeta, 当前深度, 置换表走法)
	if vl > -最高分值即将死的分值:
		return vl
	# 1-4. 尝试空步裁剪(根节点的Beta值是"最高分值即将死的分值"，所以不可能发生空步裁剪)
	if not 是否不进行空步裁剪 and not 当前棋局.是否被将军() and 当前棋局.判断是否允许空步裁剪():
		当前棋局.走一步空步()
		vl = -超出边界的AlphaBeta搜索过程(-vlBeta, 1 - vlBeta, 当前深度 - 空步裁剪的裁剪深度 - 1, 不进行空步裁剪)
		当前棋局.撤消走一步空步()
		if vl >= vlBeta:
			return vl
	# 2. 初始化最佳值和最佳走法
	nHashFlag = ALPHA节点的置换表项
	vlBest = -最高分值即将死的分值  # 这样可以知道，是否一个走法都没走过(杀棋)
	mvBest = 0  # 这样可以知道，是否搜索到了Beta走法或PV走法，以便保存到历史表
	# 3. 初始化走法排序结构
	走法排序结构_走法排序.初始化设定置换表走法和两个杀手走法(置换表走法[0])
	# 4. 逐一走这些走法，并进行递归
	这个走法 = 走法排序结构_走法排序.得到下一个走法()
	while 这个走法 != 0:
		if 当前棋局.走一步棋(这个走法):
			# 将军延伸
			nNewDepth = 当前深度 if 当前棋局.是否被将军() else (当前深度 - 1)
			# PVS
			if vlBest == -最高分值即将死的分值:
				vl = -超出边界的AlphaBeta搜索过程(-vlBeta, -vlAlpha, nNewDepth)
			else:
				vl = -超出边界的AlphaBeta搜索过程(-vlAlpha - 1, -vlAlpha, nNewDepth)
				if vl > vlAlpha and vl < vlBeta:
					vl = -超出边界的AlphaBeta搜索过程(-vlBeta, -vlAlpha, nNewDepth)
			当前棋局.撤消走一步棋()
			# 5. 进行Alpha-Beta大小判断和截断
			if vl > vlBest:  # 找到最佳值(但不能确定是Alpha、PV还是Beta走法)
				vlBest = vl  # "vlBest"就是目前要返回的最佳值，可能超出Alpha-Beta边界
				if vl >= vlBeta:  # 找到一个Beta走法
					nHashFlag = BETA节点的置换表项
					mvBest = 这个走法  # Beta走法要保存到历史表
					break  # Beta截断
				if vl > vlAlpha:  # 找到一个PV走法
					nHashFlag = PV节点的置换表项
					mvBest = 这个走法  # PV走法要保存到历史表
					vlAlpha = vl  # 缩小Alpha-Beta边界
		这个走法 = 走法排序结构_走法排序.得到下一个走法()
	# 5. 所有走法都搜索完了，把最佳走法(不能是Alpha走法)保存到历史表，返回最佳值
	if vlBest == -最高分值即将死的分值:
		# 如果是杀棋，就根据杀棋步数给出评价
		return 当前棋局.距离根节点的步数 - 最高分值即将死的分值
	# 记录到置换表
	保存置换表项(nHashFlag, vlBest, 当前深度, mvBest)
	if mvBest != 0:
		# 如果不是Alpha走法，就将最佳走法保存到历史表
		对最佳走法的处理(mvBest, 当前深度)
	return vlBest


# 根节点的Alpha-Beta搜索过程

def 根节点的AlphaBeta搜索过程(当前深度):
	走法排序结构_走法排序 = 走法排序结构()
	vlBest = -最高分值即将死的分值
	走法排序结构_走法排序.初始化设定置换表走法和两个杀手走法(与搜索有关的全局变量.电脑走的棋)
	这个走法 = 走法排序结构_走法排序.得到下一个走法()
	while 这个走法 != 0:
		if 当前棋局.走一步棋(这个走法):
			nNewDepth = 当前深度 if 当前棋局.是否被将军() else (当前深度 - 1)
			if vlBest == -最高分值即将死的分值:
				vl = -超出边界的AlphaBeta搜索过程(-最高分值即将死的分值, 最高分值即将死的分值, nNewDepth, 不进行空步裁剪)
			else:
				vl = -超出边界的AlphaBeta搜索过程(-vlBest - 1, -vlBest, nNewDepth)
				if vl > vlBest:
					vl = -超出边界的AlphaBeta搜索过程(-最高分值即将死的分值, -vlBest, nNewDepth, 不进行空步裁剪)
			当前棋局.撤消走一步棋()
			if vl > vlBest:
				vlBest = vl
				与搜索有关的全局变量.电脑走的棋 = 这个走法
				if -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 < vlBest < 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了:
					vlBest += (random.randint(0, 32767) & 随机性分值) - (random.randint(0, 32767) & 随机性分值)
		这个走法 = 走法排序结构_走法排序.得到下一个走法()
	保存置换表项(PV节点的置换表项, vlBest, 当前深度, 与搜索有关的全局变量.电脑走的棋)
	对最佳走法的处理(与搜索有关的全局变量.电脑走的棋, 当前深度)
	return vlBest


# 迭代加深搜索过程

def 迭代加深搜索过程():
	所有的走法 = [0 for i in range(最大的生成走法数)]
	# 初始化
	与搜索有关的全局变量.历史表 = [0 for i in range(65536)]  # 清空历史表
	与搜索有关的全局变量.杀手走法表 = [[0, 0] for i in range(最大的搜索深度)]  # 清空杀手走法表
	与搜索有关的全局变量.置换表 = [置换表项结构() for i in range(最大置换表大小)]  # 清空置换表

	当前棋局.距离根节点的步数 = 0  # 初始步数
	# 搜索开局库
	与搜索有关的全局变量.电脑走的棋 = 搜索开局库()
	if 与搜索有关的全局变量.电脑走的棋 != 0:
		当前棋局.走一步棋(与搜索有关的全局变量.电脑走的棋)
		if 当前棋局.检测重复局面(3) == 0:
			当前棋局.撤消走一步棋()
			return
		当前棋局.撤消走一步棋()
	# 检查是否只有唯一走法
	vl = 0
	总共有几个走法 = 当前棋局.生成所有走法(所有的走法)
	for i in range(总共有几个走法):
		if 当前棋局.走一步棋(所有的走法[i]):
			当前棋局.撤消走一步棋()
			与搜索有关的全局变量.电脑走的棋 = 所有的走法[i]
			vl += 1
	if vl == 1:
		return
	# 迭代加深过程
	t = time.process_time()  # 初始化定时器
	for i in range(1, 最大的搜索深度):
		vl = 根节点的AlphaBeta搜索过程(i)
		# 搜索到杀棋，就终止搜索
		if vl > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 or vl < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了:
			break
		# 超过i秒，就终止搜索
		if time.process_time() - t > 1:
			print('搜索深度', i, '耗时', time.process_time() - t, '秒')
			break


def 开始一局游戏():
	# 初始化全局变量
	物理.游戏是否结束
	物理.游戏是否结束 = False
	初始化Zobrist表()
	装入开局库()
	当前棋局.初始化棋盘()


def 电脑回应一步棋():
	物理.游戏是否结束
	# 电脑走一步棋
	迭代加深搜索过程()
	当前棋局.走一步棋(与搜索有关的全局变量.电脑走的棋)
	# 清除上一步棋的选择标记
	# 把电脑走的棋标记出来
	# 检查重复局面
	vlRep = 当前棋局.检测重复局面(3)
	if 当前棋局.判断是否被杀():
		# 如果分出胜负，那么播放胜负的声音，并且弹出不带声音的提示框
		物理.游戏是否结束 = "请再接再厉！"
		物理.播放音效 = 2
	elif vlRep > 0:
		vlRep = 当前棋局.重复局面分值(vlRep)
		物理.游戏是否结束 = True
		# 注意："vlRep"是对玩家来说的分值
		物理.游戏是否结束 = "长打作负，请不要气馁！" if vlRep < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else "电脑长打作负，祝贺你取得胜利！" if vlRep > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else "双方不变作和，辛苦了！"
		物理.播放音效 = 2 if vlRep < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else 1 if vlRep > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else 3
	elif 当前棋局.历史走法数 > 100:
		物理.游戏是否结束 = "超过自然限着作和，辛苦了！"
		物理.播放音效 = 3
	else:
		# 如果没有分出胜负，那么播放将军、吃子或一般走子的声音
		物理.播放音效 = 物理.播放音效 = 4 if 当前棋局.判断是否被将军() else 6 if 当前棋局.上一步是否吃子() else 5
		if 当前棋局.上一步是否吃子():
			当前棋局.初始化历史走法信息()


def 玩家走一步棋(mv):
	# 这里应检查一下走法合法，客户端已经检查，主要为防外挂
	if 当前棋局.判断走法是否合法(mv):
		if 当前棋局.走一步棋(mv):
			vlRep = 当前棋局.检测重复局面(3)
			if 当前棋局.判断是否被杀():
				物理.游戏是否结束 = "祝贺你取得胜利！"
				物理.播放音效 = 1
			elif vlRep > 0:
				vlRep = 当前棋局.重复局面分值(vlRep)
				物理.游戏是否结束 = "长打作负，请不要气馁！" if vlRep > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else "电脑长打作负，祝贺你取得胜利！" if vlRep < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else "双方不变作和，辛苦了！"
				物理.播放音效 = 2 if vlRep > 搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else 1 if vlRep < -搜索出胜负的分值界限超出此值就说明已经搜索出杀棋了 else 3
			elif 当前棋局.历史走法数 > 100:
				物理.游戏是否结束 = "超过自然限着作和，辛苦了！"
				物理.播放音效 = 3
			else:
				# 如果没有分出胜负，那么播放将军、吃子或一般走子的声音
				物理.播放音效 = 物理.播放音效 = 4 if 当前棋局.判断是否被将军() else 6 if 当前棋局.上一步是否吃子() else 5
				if 当前棋局.上一步是否吃子():
					当前棋局.初始化历史走法信息()
				电脑回应一步棋()
		else:
			物理.游戏是否结束 = '不能送将！'
			物理.播放音效 = 4


# 对玩家对弈接口，隐藏服务器编程细节

def 返回给玩家的电脑走法(re):
	start = re % 256
	end = re // 256
	start_x = start % 16 - 3
	start_y = start // 16 - 3
	end_x = end % 16 - 3
	end_y = end // 16 - 3
	return str(start_x) + str(start_y) + str(end_x) + str(end_y) + str(物理.播放音效)


def 玩家走棋交给电脑(stra):
	start_x, start_y, end_x, end_y = int(stra[0]), int(stra[1]), int(stra[2]), int(stra[3])
	return ((start_x + 3) + (start_y + 3) * 16) + ((end_x + 3) + (end_y + 3) * 16) * 256


def message(msg):
	print("recv:", msg)
	if msg == 'start':
		开始一局游戏()
	elif 物理.游戏是否结束 == False and msg[0] == '9':
		电脑回应一步棋()
		go = 返回给玩家的电脑走法(与搜索有关的全局变量.电脑走的棋)
		print('send:', go)
		return go
	elif 物理.游戏是否结束 == False:
		玩家走一步棋(玩家走棋交给电脑(msg))
		go = 返回给玩家的电脑走法(与搜索有关的全局变量.电脑走的棋)
		if 物理.游戏是否结束 == False:
			print('send:', go)
			return go
		else:
			go += 物理.游戏是否结束
			print('send:', go)
			return go


# 初始化pygame，为使用硬件做准备
pygame.init()
pygame.font.init()
pygame.mixer.init()
sound5 = pygame.mixer.Sound('img/移动.WAV')
sound4 = pygame.mixer.Sound('img/将.WAV')
sound6 = pygame.mixer.Sound('img/吃子.WAV')
sound1 = pygame.mixer.Sound('img/赢了.WAV')
sound2 = pygame.mixer.Sound('img/输了.WAV')
sound3 = pygame.mixer.Sound('img/和棋.WAV')

# 实例化字体
font = pygame.font.Font("img/fzcyjt.ttf", 30)
# 创建了一个窗口
screen = pygame.display.set_mode((510, 800), 0,
								 32)  # 返回一个Surface对象，代表了桌面上出现的窗口。第一个参数代表分辨率；第二个参数是标志位，如果不需要使用热河特性，则指定为0；第三个为色深。
# 设置窗口标题
pygame.display.set_caption("中国象棋")
# 加载并转换图像
# 载入背景图
background = pygame.image.load('img/bg.jpg').convert()
button_i = pygame.image.load('img/我先.jpg').convert()
button_u = pygame.image.load('img/电脑先.jpg').convert()
button_b = pygame.image.load('img/底条.jpg').convert()
button_i = pygame.transform.scale(button_i, (200, 80))
button_u = pygame.transform.scale(button_u, (200, 80))
button_b = pygame.transform.scale(button_b, (507, 80))
# 载入棋盘图，带透明通道
space = pygame.image.load("img/bg.png").convert_alpha()
# 载入棋子，带透明通道
b_j = pygame.image.load("img/b_j.png").convert_alpha()
b_s = pygame.image.load("img/b_s.png").convert_alpha()
b_x = pygame.image.load("img/b_x.png").convert_alpha()
b_m = pygame.image.load("img/b_m.png").convert_alpha()
b_c = pygame.image.load("img/b_c.png").convert_alpha()
b_p = pygame.image.load("img/b_p.png").convert_alpha()
b_z = pygame.image.load("img/b_z.png").convert_alpha()
r_j = pygame.image.load("img/r_j.png").convert_alpha()
r_s = pygame.image.load("img/r_s.png").convert_alpha()
r_x = pygame.image.load("img/r_x.png").convert_alpha()
r_m = pygame.image.load("img/r_m.png").convert_alpha()
r_c = pygame.image.load("img/r_c.png").convert_alpha()
r_p = pygame.image.load("img/r_p.png").convert_alpha()
r_z = pygame.image.load("img/r_z.png").convert_alpha()
select = pygame.image.load("img/r_box.png").convert_alpha()
text = '请选择谁先走'
win = font.render(text, False, (255, 200, 10))
fpsClock = pygame.time.Clock()

h = (0, 57, 114, 171, 228, 285, 342, 399, 456, -100)
z = (0, 57, 114, 171, 228, 285, 342, 399, 456, 513, -100)

q = [
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
	['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
]
x, y = 9, 10
x0, y0 = 9, 10
x1, y1 = 9, 10
eat = ''
is_select = False
is_go = False
is_red = 1
is_ai_red = 2  # AI执红为1,执黑为0,玩家互玩设为2,默认为2
is_reverse = False  # 翻转棋盘


def reverseqp():
	global is_reverse
	is_reverse = not is_reverse
	global q
	q.reverse()
	global y
	global y0
	global y1
	y, y0, y1 = 9 - y, 9 - y0, 9 - y1


def restartgame(isred):
	global text
	global win
	text = '游戏开始，请下第一步' if isred == 0 else '电脑思考中'
	win = font.render(text, False, (255, 200, 10))
	global q
	global is_reverse
	q = [
		['b_c', 'b_m', 'b_x', 'b_s', 'b_j', 'b_s', 'b_x', 'b_m', 'b_c', ],
		['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
		['xxx', 'b_p', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'b_p', 'xxx', ],
		['b_z', 'xxx', 'b_z', 'xxx', 'b_z', 'xxx', 'b_z', 'xxx', 'b_z', ],
		['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
		['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
		['r_z', 'xxx', 'r_z', 'xxx', 'r_z', 'xxx', 'r_z', 'xxx', 'r_z', ],
		['xxx', 'r_p', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'r_p', 'xxx', ],
		['xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', 'xxx', ],
		['r_c', 'r_m', 'r_x', 'r_s', 'r_j', 'r_s', 'r_x', 'r_m', 'r_c', ],
	]
	if isred:
		is_reverse = True
		q.reverse()
	else:
		is_reverse = False
	global x
	global y
	x, y = 9, 10
	global x0
	global y0
	x0, y0 = 9, 10
	global x1
	global y1
	x1, y1 = 9, 10
	global is_select
	is_select = False
	global is_go
	is_go = False
	global is_red
	is_red = 1
	global is_ai_red
	is_ai_red = isred  # AI执红为1,执黑为0,玩家互玩设为2
	message('start')  # 重新开始一局游戏


def can(qp, qz, x, y):  # 着法合规性判断函数
	n = set()  # 创建一个空集合
	x1, y1, x2, y2 = x, y, x, y
	if qz[2] == 'c':
		while x1 < 8:  # 向右搜索
			x1 += 1
			n.add((x1, y))
			if qp[y][x1][1] == '_':
				break
		while x2 > 0:  # 向左搜索
			x2 -= 1
			n.add((x2, y))
			if qp[y][x2][1] == '_':
				break
		while y1 < 9:  # 向下搜索
			y1 += 1
			n.add((x, y1))
			if qp[y1][x][1] == '_':
				break
		while y2 > 0:  # 向上搜索
			y2 -= 1
			n.add((x, y2))
			if qp[y2][x][1] == '_':
				break
	elif qz[2] == 'm':
		x1 += 1
		x2 -= 1
		y1 += 1
		y2 -= 1
		if -1 < x < 7 and qp[y][x1] == 'xxx':  # 向右
			if y < 9:
				n.add((x1 + 1, y1))  # 右下
			if y > 0:
				n.add((x1 + 1, y2))  # 右上
		if 1 < x < 9 and qp[y][x2] == 'xxx':  # 向左
			if y < 9:
				n.add((x2 - 1, y1))  # 左下
			if y > 0:
				n.add((x2 - 1, y2))  # 左上
		if -1 < y < 8 and qp[y1][x] == 'xxx':  # 向下
			if x < 8:
				n.add((x1, y1 + 1))  # 下右
			if x > 0:
				n.add((x2, y1 + 1))  # 下左
		if 1 < y < 10 and qp[y2][x] == 'xxx':  # 向上
			if x < 8:
				n.add((x1, y2 - 1))  # 上右
			if x > 0:
				n.add((x2, y2 - 1))  # 上左
	elif qz[2] == 'p':
		o = 1
		while x1 < 8:  # 向右搜索
			x1 += 1
			if o and qp[y][x1] == 'xxx':
				n.add((x1, y))
			if qp[y][x1][1] == '_':
				if not o:
					n.add((x1, y))
					break
				o = 0
		o = 1
		while x2 > 0:  # 向左搜索
			x2 -= 1
			if o and qp[y][x2] == 'xxx':
				n.add((x2, y))
			if qp[y][x2][1] == '_':
				if not o:
					n.add((x2, y))
					break
				o = 0
		o = 1
		while y1 < 9:  # 向下搜索
			y1 += 1
			if o and qp[y1][x] == 'xxx':
				n.add((x, y1))
			if qp[y1][x][1] == '_':
				if not o:
					n.add((x, y1))
					break
				o = 0
		o = 1
		while y2 > 0:  # 向上搜索
			y2 -= 1
			if o and qp[y2][x] == 'xxx':
				n.add((x, y2))
			if qp[y2][x][1] == '_':
				if not o:
					n.add((x, y2))
					break
				o = 0
	elif qz[2] == 'x':
		x1 += 2
		x2 -= 2
		y1 += 2
		y2 -= 2
		if y == 5 or y == 0 or x == 4:
			if qp[y + 1][x + 1] == 'xxx':
				n.add((x1, y1))
			if qp[y + 1][x - 1] == 'xxx':
				n.add((x2, y1))
		if y == 9 or y == 4 or x == 4:
			if qp[y - 1][x + 1] == 'xxx':
				n.add((x1, y2))
			if qp[y - 1][x - 1] == 'xxx':
				n.add((x2, y2))
		elif x == 0:
			if qp[y + 1][x + 1] == 'xxx':
				n.add((x1, y1))
			if qp[y - 1][x + 1] == 'xxx':
				n.add((x1, y2))
		elif x == 8:
			if qp[y + 1][x - 1] == 'xxx':
				n.add((x2, y1))
			if qp[y - 1][x - 1] == 'xxx':
				n.add((x2, y2))
	elif qz[2] == 's':
		if y == 0 or y == 7:
			n.add((4, y + 1))
		elif y == 2 or y == 9:
			n.add((4, y - 1))
		else:
			n.add((x + 1, y + 1))
			n.add((x + 1, y - 1))
			n.add((x - 1, y + 1))
			n.add((x - 1, y - 1))
	elif qz[2] == 'j':
		if x == 3 or x == 5:
			n.add((4, y))
		else:
			n.add((3, y))
			n.add((5, y))
		if y == 0 or y == 2:
			n.add((x, 1))
		elif y == 7 or y == 9:
			n.add((x, 8))
		else:
			n.add((x, y + 1))
			n.add((x, y - 1))
	elif qz[2] == 'z':
		if qz[0] == ('b' if is_reverse else 'r'):
			if y != 0:
				n.add((x, y - 1))
			if y < 5:
				if x > 0:
					n.add((x - 1, y))
				if x < 8:
					n.add((x + 1, y))
		else:
			if y != 9:
				n.add((x, y + 1))
			if y > 4:
				if x > 0:
					n.add((x - 1, y))
				if x < 8:
					n.add((x + 1, y))
	return n


while True:
	# 以下是刷新显示程序
	screen.blit(background, (0, 0))  # 画上背景图
	screen.blit(space, (2, 0))  # 画上棋盘
	screen.blit(button_b, (2, 577))
	screen.blit(button_i, (30, 680))
	screen.blit(button_u, (290, 680))
	screen.blit(win, (20, 600))
	# 画上棋子
	for i in range(10):
		for j in range(9):
			if q[i][j] != 'xxx':
				if q[i][j][0] == 'b':
					if q[i][j][2] == 'j':
						screen.blit(b_j, (h[j], z[i]))
					elif q[i][j][2] == 's':
						screen.blit(b_s, (h[j], z[i]))
					elif q[i][j][2] == 'x':
						screen.blit(b_x, (h[j], z[i]))
					elif q[i][j][2] == 'm':
						screen.blit(b_m, (h[j], z[i]))
					elif q[i][j][2] == 'c':
						screen.blit(b_c, (h[j], z[i]))
					elif q[i][j][2] == 'p':
						screen.blit(b_p, (h[j], z[i]))
					else:
						screen.blit(b_z, (h[j], z[i]))
				else:
					if q[i][j][2] == 'j':
						screen.blit(r_j, (h[j], z[i]))
					elif q[i][j][2] == 's':
						screen.blit(r_s, (h[j], z[i]))
					elif q[i][j][2] == 'x':
						screen.blit(r_x, (h[j], z[i]))
					elif q[i][j][2] == 'm':
						screen.blit(r_m, (h[j], z[i]))
					elif q[i][j][2] == 'c':
						screen.blit(r_c, (h[j], z[i]))
					elif q[i][j][2] == 'p':
						screen.blit(r_p, (h[j], z[i]))
					else:
						screen.blit(r_z, (h[j], z[i]))
	if is_select == True:
		screen.blit(select, (h[x], z[y]))  # 画上选择框
	if is_go == True and is_select == False:
		# 画上两个选择框
		screen.blit(select, (h[x0], z[y0]))
		screen.blit(select, (h[x1], z[y1]))
	pygame.display.update()  # 刷新画面
	fpsClock.tick(30)
	# 以下是下棋控制
	if is_ai_red == is_red:  # 轮到AI下
		msg = str(x) + str(9 - y if is_reverse else y) + str(x1) + str(9 - y1 if is_reverse else y1)
		data = message(msg)
		if '送将' in data[5:]:
			sound4.play()
			text = data[5:]
			win = font.render(text, False, (255, 200, 10))
			物理.游戏是否结束 = False
			q[y][x] = q[y1][x1]  # 恢复原位
			q[y1][x1] = eat  # 空位还原
			is_red = 1 - is_red
			continue
		x, y, x1, y1, bo = int(data[0]), 9 - int(data[1]) if is_reverse else int(data[1]), int(data[2]), 9 - int(
			data[3]) if is_reverse else int(data[3]), data[4]
		locals()['sound' + bo].play()  # 播放对应的声音
		q[y1][x1] = q[y][x]  # 吃空气或吃子
		q[y][x] = 'xxx'  # 原位留空
		x0, y0 = x, y  # 记录位置赋值
		is_red = 1 - is_red
		is_go = True
		is_select = False
		if len(data) > 5:
			# 显示文本并跳出循环，等待玩家重启游戏
			text = data[5:]
			win = font.render(text, False, (255, 200, 10))
			is_ai_red = 2
			continue
		text = '轮到你下了'
		win = font.render(text, False, (255, 200, 10))
	else:  # 玩家下
		# screen.fill((0, 0, 0))
		for event in pygame.event.get():
			if event.type == QUIT:  # 接收到退出事件后退出程序
				pygame.quit()
				exit()
			# 选取棋子
			if event.type == MOUSEBUTTONUP:  # 鼠标点击后松开
				mp = pygame.mouse.get_pos()  # 获取鼠标点击位置
				# 先判断是否点击了控制按钮
				if 760 > mp[1] > 680:
					if 230 > mp[0] > 30:  # 我先
						restartgame(0)
					elif 490 > mp[0] > 290:
						restartgame(1)
					break
				if is_go == False and is_select == True:  # 已选中棋子
					# 判断鼠标点击的位置是否能落子
					if mp[0] < h[0] or mp[0] >= h[8] + 57 or mp[1] < z[0] or mp[1] >= z[9] + 57:
						pass
					elif mp[0] < h[1]:
						x1 = 0
					elif mp[0] < h[2]:
						x1 = 1
					elif mp[0] < h[3]:
						x1 = 2
					elif mp[0] < h[4]:
						x1 = 3
					elif mp[0] < h[5]:
						x1 = 4
					elif mp[0] < h[6]:
						x1 = 5
					elif mp[0] < h[7]:
						x1 = 6
					elif mp[0] < h[8]:
						x1 = 7
					elif mp[0] < h[8] + 57:
						x1 = 8
					if mp[0] < h[0] or mp[0] >= h[8] + 57 or mp[1] < z[0] or mp[1] >= z[9] + 57:
						pass
					elif mp[1] < z[1]:
						y1 = 0
					elif mp[1] < z[2]:
						y1 = 1
					elif mp[1] < z[3]:
						y1 = 2
					elif mp[1] < z[4]:
						y1 = 3
					elif mp[1] < z[5]:
						y1 = 4
					elif mp[1] < z[6]:
						y1 = 5
					elif mp[1] < z[7]:
						y1 = 6
					elif mp[1] < z[8]:
						y1 = 7
					elif mp[1] < z[9]:
						y1 = 8
					elif mp[1] < z[9] + 57:
						y1 = 9  # 先完成对x1y1的赋值
					if is_red:
						if q[y1][x1][0] != 'r':  # 如果选择的落子点上没有红棋
							# 落子
							is_can = can(q, q[y][x], x, y)
							if (x1, y1) in is_can:
								if q[y1][x1][1] == '_':
									sound6.play()
								else:
									sound5.play()
								eat = q[y1][x1]  # 记录吃了啥子，用于送将退回
								q[y1][x1] = q[y][x]  # 吃空气或吃子
								q[y][x] = 'xxx'  # 原位留空
								x0, y0 = x, y  # 记录位置赋值
								is_red = 0
								is_go = True
								is_select = False
								text = '电脑思考中'
								win = font.render(text, False, (255, 200, 10))
						else:  # 不能落子：
							is_select = False
					else:  # is_red == 0:
						if q[y1][x1][0] != 'b':  # 如果选择的落子点上没有黑棋
							# 落子
							is_can = can(q, q[y][x], x, y)
							if (x1, y1) in is_can:
								if q[y1][x1][1] == '_':
									sound6.play()
								else:
									sound5.play()
								q[y1][x1] = q[y][x]  # 吃空气或吃子
								q[y][x] = 'xxx'  # 原位留空
								x0, y0 = x, y  # 记录位置赋值
								is_red = 1
								is_go = True
								is_select = False
								text = '电脑思考中'
								win = font.render(text, False, (255, 200, 10))
						else:  # 不能落子：
							is_select = False
				else:  # 未选中棋子
					if mp[0] < h[0] or mp[0] >= h[8] + 57 or mp[1] < z[0] or mp[1] >= z[9] + 57:
						pass
					elif mp[0] < h[1]:
						x = 0
					elif mp[0] < h[2]:
						x = 1
					elif mp[0] < h[3]:
						x = 2
					elif mp[0] < h[4]:
						x = 3
					elif mp[0] < h[5]:
						x = 4
					elif mp[0] < h[6]:
						x = 5
					elif mp[0] < h[7]:
						x = 6
					elif mp[0] < h[8]:
						x = 7
					elif mp[0] < h[8] + 57:
						x = 8
					if mp[0] < h[0] or mp[0] >= h[8] + 57 or mp[1] < z[0] or mp[1] >= z[9] + 57:
						reverseqp()  # 点在棋盘正下方的其他位置，翻转显示
						continue
					elif mp[1] < z[1]:
						y = 0
					elif mp[1] < z[2]:
						y = 1
					elif mp[1] < z[3]:
						y = 2
					elif mp[1] < z[4]:
						y = 3
					elif mp[1] < z[5]:
						y = 4
					elif mp[1] < z[6]:
						y = 5
					elif mp[1] < z[7]:
						y = 6
					elif mp[1] < z[8]:
						y = 7
					elif mp[1] < z[9]:
						y = 8
					elif mp[1] < z[9] + 57:
						y = 9
					if is_red == 1:
						if q[y][x][1] == '_' and q[y][x][0] == 'r':
							is_select = True
							is_go = False
						else:
							is_select = False
					else:
						if q[y][x][1] == '_' and q[y][x][0] == 'b':
							is_select = True
							is_go = False
						else:
							is_select = False